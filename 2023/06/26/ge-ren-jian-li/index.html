<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="个人简历总结, 爱敲代码の鱼儿">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>个人简历总结 | 爱敲代码の鱼儿</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="爱敲代码の鱼儿" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">爱敲代码の鱼儿</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">爱敲代码の鱼儿</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd.toString !==
            CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Utf8)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">个人简历总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-26
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="0-JavaGuide"><a href="#0-JavaGuide" class="headerlink" title="0.JavaGuide"></a>0.JavaGuide</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a></p>
<p>这里面的东西也是推荐要看一看的。</p>
<span id="more"></span>

<h1 id="1-Java"><a href="#1-Java" class="headerlink" title="1.Java"></a>1.Java</h1><h2 id="ArrayList源码"><a href="#ArrayList源码" class="headerlink" title="ArrayList源码"></a>ArrayList源码</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17F411T7Ao?p=190&vd_source=6ed7f19911310aba47123ac6cc1674a0">参考资料</a></p>
<p>1.用空参创建的集合，在底层创建一个默认长度为0的数组。</p>
<p>2.添加第一个元素时，底层会创建一个新的长度为10的数组。</p>
<p>3.存满时，会扩容1.5倍。</p>
<p>4.如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。</p>
<p>ctrl+shift+t 可以查ArrayList源码</p>
<p>ctrl + o 搜索指定的方法。</p>
<p>源码：add函数 add(e,elementData,size)</p>
<p>参数一：当前要添加的元素 参数二：集合底层的数组名字 参数三：集合的长度&#x2F;当前元素应存入的位置</p>
<p>源码 newLength(int oldLength,int minGrowth,int prefGrowth)</p>
<p>int prefLength&#x3D;oldLength+Math.max(minGrowth,prefGrowth);</p>
<p>扩容因子1.5，一方面是位运算比较快，一方面是1.5可以让之前的内存空间可以得到复用。</p>
<h2 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A84y1M73v/?spm_id_from=333.999.0.0&vd_source=6ed7f19911310aba47123ac6cc1674a0">参考资料1</a></p>
<p>加载因子0.75， 超过时会扩容为2倍。扩容之后桶下标要重新计算。</p>
<p>树化：当容量大于等于64时，且一个Key下面的链表长度大于8。 将链表转为红黑树</p>
<p>退化：扩容会拆分，当树的元素个数小于等于6，会退化为链表。remove之前，如果root.root.left, root.right, root.left.left如果有一个为null,则会退化为链表</p>
<p>数组容量为什么是2的n次幂？ 计算索引时，如果是2的n次幂，可以使用位与运算代替取模，效率更高；扩容时oldCap &amp; hash &#x3D;&#x3D;0 的元素留在原来位置，否则新位置&#x3D;旧位置+oldCap</p>
<p>例子：容量16时，10&amp;16&#x3D;0,26&amp;16&#x3D;16.这俩都在10的位置。(新位置)26&#x3D;10+16</p>
<p>但是这样可能会导致哈希分布性不好，所以也推荐选质数。比如HashTable{0-&gt;11-&gt;23-&gt;47-&gt;95}</p>
<p>HashMap不是线程安全的，多线程操作会造成数据错乱现象。</p>
<p>HashMap的key可以为Null，其他的map不行</p>
<p>作为key的对象，必须要实现hashCode和equals,并且Key的内容不能修改</p>
<p>String对象的hashCode（）如何设计才能让散列的更加均匀？</p>
<p>每个字符串的hashCode足够独特，$S_0$×$31^{n-1}$+……+$S_{n-1}$×$31^0$</p>
<p>31×h又可以被优化为h&lt;&lt;5 - h</p>
<h1 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2.计算机网络"></a>2.计算机网络</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-从输入URL到页面展示到底发生了什么？（打开一个网页，整个过程会使用哪些协议）"><a href="#1-从输入URL到页面展示到底发生了什么？（打开一个网页，整个过程会使用哪些协议）" class="headerlink" title="1)从输入URL到页面展示到底发生了什么？（打开一个网页，整个过程会使用哪些协议）"></a>1)从输入URL到页面展示到底发生了什么？（打开一个网页，整个过程会使用哪些协议）</h3><p>注意是OSPF协议。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>DNS解析：一个网址到IP地址的转换。</p>
<p>浏览器中有DNS缓存，DNS负载均衡可以把最近的IP地址返回给用户。DNS端口是53</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/1618288278-57f00bf9444dd.png" alt="img"></p>
<h3 id="2-HTTP-和-HTTPS-的区别"><a href="#2-HTTP-和-HTTPS-的区别" class="headerlink" title="2)HTTP 和 HTTPS 的区别"></a>2)HTTP 和 HTTPS 的区别</h3><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/http-vs-https.png" alt="img"></p>
<h3 id="3-HTTP1-0-和-HTTP1-1的区别"><a href="#3-HTTP1-0-和-HTTP1-1的区别" class="headerlink" title="3)HTTP1.0 和 HTTP1.1的区别"></a>3)HTTP1.0 和 HTTP1.1的区别</h3><p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/http1.0-vs-http1.1.png" alt="img"></p>
<p>连接方式：HTTP&#x2F;1.0 为短连接，HTTP&#x2F;1.1 支持长连接。</p>
<p>状态响应码： HTTP&#x2F;1.1 中新加入了大量的状态码，</p>
<p>缓存机制：HTTP&#x2F;1.1 则引入了更多的缓存控制策略</p>
<p>带宽： HTTP&#x2F;1.1它允许只请求资源的某个部分，即返回码是 206（Partial Content）</p>
<p>Host 头（Host Header）处理 :HTTP&#x2F;1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。</p>
<h3 id="4-HTTP1-1-和-HTTP2-0-的区别"><a href="#4-HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="4)HTTP1.1 和 HTTP2.0 的区别"></a>4)HTTP1.1 和 HTTP2.0 的区别</h3><p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/http1.1-vs-http2.0.png" alt="img"></p>
<p><strong>IO 多路复用（Multiplexing）</strong> ：HTTP&#x2F;2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP&#x2F;1.1 中长链接的升级版本）。HTTP&#x2F;1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP&#x2F;2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</p>
<p><strong>二进制帧（Binary Frames）</strong> ：HTTP&#x2F;2.0 使用二进制帧进行数据传输，而 HTTP&#x2F;1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
<p><strong>头部压缩（Header Compression）</strong> ：HTTP&#x2F;1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP&#x2F;2.0 支持对<code>Header</code>压缩，减少了网络开销。</p>
<p><strong>服务器推送（Server Push）</strong>：HTTP&#x2F;2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP&#x2F;1.1 需要客户端自己发送请求来获取相关资源。</p>
<h3 id="5-HTTP2-0-和-HTTP-3-0的区别"><a href="#5-HTTP2-0-和-HTTP-3-0的区别" class="headerlink" title="5)HTTP2.0 和 HTTP 3.0的区别"></a>5)HTTP2.0 和 HTTP 3.0的区别</h3><p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/http2.0-vs-http3.0.png" alt="img"></p>
<p><strong>传输协议</strong> ：HTTP&#x2F;2.0 是基于 TCP 协议实现的，HTTP&#x2F;3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS&#x2F;SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP&#x2F;3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP&#x2F;3 最大的改造就是使用了 QUIC。</p>
<p><strong>连接建立</strong> ：HTTP&#x2F;2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP&#x2F;3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</p>
<p><strong>队头阻塞</strong> ：HTTP&#x2F;2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP&#x2F;3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p><strong>错误恢复</strong> ：HTTP&#x2F;3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP&#x2F;2.0 则需要依赖于 TCP 的错误恢复机制。</p>
<p><strong>安全性</strong> ：HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP&#x2F;2.0 使用 TLS 协议进行加密，而 HTTP&#x2F;3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</p>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><h3 id="1-TCP-与-UDP-的区别"><a href="#1-TCP-与-UDP-的区别" class="headerlink" title="1)TCP 与 UDP 的区别"></a>1)TCP 与 UDP 的区别</h3><ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ol>
<h3 id="2-TCP-的三次握手的过程"><a href="#2-TCP-的三次握手的过程" class="headerlink" title="2) TCP 的三次握手的过程"></a>2) TCP 的三次握手的过程</h3><p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/tcp-shakes-hands-three-times.png" alt="img"></p>
<p>三次握手能够保证自己和对方的发送和接收功能都是正常的。</p>
<h3 id="3-四次挥手"><a href="#3-四次挥手" class="headerlink" title="3)四次挥手"></a>3)四次挥手</h3><p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/tcp-waves-four-times.png" alt="img"></p>
<p>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</p>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送.</p>
<p>当被动关闭方（服务端）在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/d7b349efa4f94453943b433b704a4ca8.webp" alt="img"></p>
<p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/33f3d2d54a924b0a80f565038327e0e4.webp" alt="img"></p>
<h3 id="4-TCP传输可靠性保证"><a href="#4-TCP传输可靠性保证" class="headerlink" title="4)TCP传输可靠性保证"></a>4)TCP传输可靠性保证</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html#tcp-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">JavaGuide链接</a></p>
<h3 id="5-NAT的作用"><a href="#5-NAT的作用" class="headerlink" title="5) NAT的作用"></a>5) NAT的作用</h3><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3.设计模式"></a>3.设计模式</h1><p>软件设计原则：</p>
<p>开闭原则：对拓展开放，对修改封闭。<br>里式代换原则：任何基类可以出现的地方，子类一定可以出现，反之不一定。<br>依赖倒转原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象。<br>接口隔离原则：客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。<br>迪米特法则：只和你的直接朋友交谈，不跟 “陌生人” 说话<br>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>设计模式分类：</p>
<p>创建型：专注于对象的创建</p>
<p>结构型：关注类和对象的组织</p>
<p>行为型：关注对象之间的相互交互</p>
<p>创建型模式：单例模式、工厂模式、原型模式、建造者模式</p>
<p>结构型模式：代理模式、适配器模式、装饰器模式、桥接模式、外观模式、组合模式、享元模式</p>
<p>行为型模式：模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一个类只有一个实例</p>
<p>掌握单例模式常见五种实现方式</p>
<p>了解jdk中有哪些地方体现了单例模式</p>
<ul>
<li><strong>饿汉式</strong>：类加载就会导致该单实例对象被创建</li>
<li><strong>懒汉式</strong>：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://luzhenyu.blog.csdn.net/article/details/122308030">文章</a></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>简单工厂模式：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/26943a5bf49846279f3b92999aa966dc.png" alt="img"></p>
<pre><code>简单咖啡工厂类，用来生产咖啡`
`*/`
`public class SimpleCoffeeFactory &#123;`
`public Coffee createCoffee(String type) &#123;`
`// 声明Coffee类型的变量，根据不同类型创建不同的coffee子类对象`
`Coffee coffee = null;`
`if (&quot;american&quot;.equals(type)) &#123;`
`coffee = new AmericanCoffee();`
`&#125; else if (&quot;latte&quot;.equals(type)) &#123;`
`coffee = new LatteCoffee();`
`&#125; else &#123;`
`throw new RuntimeException(&quot;对不起，您所点的咖啡没有&quot;);`
`&#125;`
`return coffee;`
`&#125;`
`&#125;
</code></pre>
<p>你传入type，然后工厂来生产。如果要增加新产品直接修改工厂类，容易扩展，但也违反了“开闭”原则。</p>
<p>工厂方法模式：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/76b882ee722549eaa15930d73d92b741.png" alt="img"></p>
<p>分为抽象工厂，具体工厂；抽象产品，具体产品。</p>
<p>无需对原工厂修改，满足开闭原则。但是有新产品就要新建工厂。</p>
<p>抽象工厂模式：</p>
<p><strong>工厂方法模式</strong>：一个工厂生产一种类对象的模式。</p>
<p><strong>抽象工厂模式</strong>：一个工厂可以生产多种类对象的模式。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/6c9c12ff920545b4b910a3864548a36a.png" alt="img"></p>
<p>意大利风味的甜品工厂 ,生产拿铁咖啡和提拉米苏甜品</p>
<p>美式风味的甜品工厂 ，生产美式咖啡和抹茶慕斯</p>
<p>有咖啡和甜品两个产品族。</p>
<p><a target="_blank" rel="noopener" href="https://luzhenyu.blog.csdn.net/article/details/122318746">文章</a></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的作用：保护、增强、解耦</p>
<p>当访问对象不适合或者不能直接引用目标对象，可以提供一个代理以控制对该对象的访问，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理；</p>
<p>静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成；</p>
<p>动态代理又有 JDK 代理和 CGLib 代理两种。</p>
<p>静态代理：火车站是目标对象，代售点是代理对象。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/7accab7a41f149fe8605f3d99b8e1c2c.png" alt="img"></p>
<p><strong>JDK 动态代理要求必须定义接口，因为它只能对接口进行代理。</strong></p>
<p>获取代理对象的工厂类 ProxyFactory。</p>
<p>CGLIB 动态代理可以不代理接口，直接代理类。</p>
<p>使用场景：远程代理我们只能访问接口。</p>
<p><a target="_blank" rel="noopener" href="https://luzhenyu.blog.csdn.net/article/details/122362769#518__404">文章</a></p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>原来的话：<br><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/5feae29f62384cc881b0960a4ed82883.png" alt="img"></p>
<p>改进之后：<br><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/62b392a8f1b34e939ca4f6cd9676e630.png" alt="img"></p>
<p>使用场景：</p>
<p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
<p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
<p>JDK里面的IO流的包装类用到了装饰器模式</p>
<p>BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<p>BufferedWriter 使用装饰者模式对 Writer 子实现类进行了增强，添加了缓冲区，提高了写数据的效率</p>
<p>代理和装饰者的区别：</p>
<p>相同点：</p>
<p>都要实现与目标类相同的业务接口<br>在两个类中都要声明目标对象<br>都可以在不修改目标类的前提下增强目标方法<br>不同点：</p>
<p>目的不同</p>
<p>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象（装饰者可以迭代增强，代理只能增强一次）</p>
<p>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</p>
<p><a target="_blank" rel="noopener" href="https://luzhenyu.blog.csdn.net/article/details/122579712">文章</a></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>又被称为 发布 - 订阅（Publish &#x2F; Subscribe）模式, 监听器。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/dfb0e1b6e46b478ca073786f554effcc.png" alt="img"></p>
<p>优点：解耦，可以实现广播机制。</p>
<h1 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4.MySQL"></a>4.MySQL</h1><h2 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构.</p>
<p>优点：查的快，降低IO成本； 通过创建唯一索引，可以保证数据的唯一性； 加速表与表之间的连接，减低分组和排序子句的时间。</p>
<p>缺点：创建索引和维护索引要耗费时间； 索引需要占磁盘空间； 索引会降低更新表的速度。</p>
<p>底层数据结构：B+树，很适合排序查找和范围查找。</p>
<p>聚簇索引：所有的用户记录都存在了叶⼦节点，数据即索引，索引即数据。以主键值大小进行排序。</p>
<p>非聚簇索引：以别的键为搜索条件时使用，回表。</p>
<p>联合索引：可以先按C2列排序，再按C3列排序。</p>
<p>InnoDB的B+树索引的注意事项</p>
<p>1.根页面位置不动 2.非叶子节点目录项记录唯一 3.一个页面最少存储两条记录</p>
<p>MyISAM索引：将数据和索引分开存储，索引树的叶子节点存的是主键值+数据记录地址</p>
<p>MyISAM与InnoDB的对比：<br>1.InnoDB中，根据主键值对聚簇索引进行一次查询即可。而在MyISAM中，要进行一次回表。MyISAM的回表操作是十分 快速 的。</p>
<p>2.InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</p>
<p>3.InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。</p>
<p>4.InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。再没有的话可以生成一个隐含字段。</p>
<p>B+树优点：B+树查询效率更稳定（要访问到叶子节点）； B+树的查询效率更高（一般比B树更矮胖）；B+树的磁盘读写代价更低（因为内部非叶子节点存储的东西更少）</p>
<p>B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO？ InnoDB存储引擎中页的大小为16KB，一个int类型或者一个指针也就4个字节或者8个字节。所以一个页可以存储16KB&#x2F;(8B+8B)&#x3D;1000个键值。则深度为3的树就可以存储$10^3$×*$10^3$×$10^3$&#x3D;一亿条数据</p>
<h2 id="Innodb存储引擎"><a href="#Innodb存储引擎" class="headerlink" title="Innodb存储引擎"></a>Innodb存储引擎</h2><p>InnoDB中页的大小默认为16KB，以页作为磁盘和内存之间交互的基本单位。</p>
<p>因为每次是将这个记录所在的页加载到内存中进行读取。一个页中有上千条记录。所以普通索引和唯一索引的性能差异不大。</p>
<p>引入 区 的概念，一个区就是在物理位置上连续的 64个页。因为InnoDB 中的页大小默认是16KB，所以 一个区的大小是64*16KB&#x3D; 1MB 。</p>
<p>InnoDB对 B+树的 叶子节点 和 非叶子节点 进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自 己独有的区。存放叶子节点的区的集合就算是一个 段( segment) ，存放非叶子节点的区的集合也算是 一个段。</p>
<p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些 完整的区组成。</p>
<p>为了考虑以完整的区为单位分配给某个段对于 数据量较小 的表太浪费存储空间的这种情况，InnoDB提 出了一个 碎片(fragment)区 的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据 而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至 哪个段都不属于。 碎片区直属于表空间 ，并不属于任何一个段。</p>
<p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。 表空间是一个 逻辑容器 ，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只 能属于一个表空间。</p>
<h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p>首先要开启慢查询，指定一下阈值(默认是10s)</p>
<p>慢查询日志分析工具：mysqldumpslow</p>
<p>EXPLAIN加在查询语句前面。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>最佳左前缀法则</p>
<p>计算，函数，类型转换导致索引失效。</p>
<p>范围条件右边的列索引失效</p>
<p>不等于(!&#x3D; 或者 &lt;&gt;)索引失效</p>
<p>is null 可以使用索引， is not null 无法使用索引</p>
<p>like 以通配符%开头索引失效</p>
<p>OR前后存在非索引的列，索引失效</p>
<p>覆盖索引：简单说就是， 索引列+主键 包含 SELECT 到 FROM之间查询的列 。。</p>
<p>索引下推：本来有100条需要回表，但是where里面有 name like %张%, 所以也可以用一下这种索引去查张，把回表数降为10.</p>
<p>关于exits和In</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/%E7%AE%80%E5%8E%861/QQ%E5%9B%BE%E7%89%8720230519205651.png" alt="img"></p>
<h2 id="事务与锁"><a href="#事务与锁" class="headerlink" title="事务与锁"></a>事务与锁</h2><h3 id="1-事务基础知识"><a href="#1-事务基础知识" class="headerlink" title="1)事务基础知识"></a>1)事务基础知识</h3><p>在MySQL中，只有InnoDB是支持事务的。</p>
<p>事务的ACID特性：<br>原子性（atomicity): 要么全部提交，要么全部失败回滚。</p>
<p>一致性(consistency)：指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。</p>
<p>隔离性(isolation): 指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>持久性(durability): 一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。</p>
<p>事务的状态：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230423093117.png" alt="img"></p>
<p>事务的使用： BEGIN; COMMIT; ROLLBACK;</p>
<p>数据并发问题 : 脏写，脏读，不可重复读，幻读</p>
<p>1)脏写（Dirty Write): 事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数据</p>
<ol>
<li>脏读(Dirty Read): Session A 读取 了已经被 Session B <strong>更新 但还 没有被提交</strong> 的字段。 之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的.</li>
<li>不可重复读(Non-Repeatable Read):Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后 Session A 再次读取 同一个字段， 值就不同 了。</li>
</ol>
<p>4)幻读(Phantom): Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。</p>
<p>四种隔离级别：未提交读，提交读，可重复读，序列化</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230423104501.png" alt="img"></p>
<p>脏写的问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>MySQL的默认隔离级别为REPEATABLE READ。</p>
<h3 id="2-MySQL事务日志"><a href="#2-MySQL事务日志" class="headerlink" title="2)MySQL事务日志"></a>2)MySQL事务日志</h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<p>事务的隔离性由 锁机制 实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。</p>
<p><strong>REDO LOG</strong> 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。</p>
<p><strong>UNDO LOG</strong> 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p>
<p>redo log:只需要把 修改 了哪些东西 记录一下 就好.</p>
<p>好处：redo日志降低了刷盘频率 redo日志占用的空间非常小</p>
<p>特点：redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录</p>
<p>redo log的组成：(保存在内存中的) 重做日志的缓冲 (redo log buffer)，(保存在磁盘中的)重做日志文件 (redo log file)</p>
<p>redo log 的流程：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230423112516.png" alt="img"></p>
<p>刷盘：就是将redo log buffer的东西写入到磁盘中（即redo log file)中。</p>
<p>InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。</p>
<p>它支持三种策略：</p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）</p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p>
<p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要 先写入一个 undo log 。</p>
<p>undo log 的作用： 1. 回滚 2.MVCC</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230423134009.png" alt="img"></p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程.</p>
<h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3)锁"></a>3)锁</h3><p>事务的隔离性由 锁来实现</p>
<p>怎么解决脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：</p>
<p>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。</p>
<p>方案二：读、写操作都采用 加锁 的方式。</p>
<p>锁的分类：</p>
<p>按对数据的操作类型划分：读锁&#x2F;共享锁(S)， 写锁&#x2F;排他锁(X)</p>
<p>按锁的粒度划分： 表级锁， 行级锁， 页级锁</p>
<p>按对锁的态度：悲观锁，乐观锁</p>
<p>按加锁方式： 隐式锁， 显示锁</p>
<p><strong>Java中 synchronized 和 ReentrantLock 等独占锁就是 悲观锁思想的实现</strong></p>
<p>乐观锁：在更新 的时候会判断一下在此期间别人有没有去更新这个数据。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了<strong>乐观锁的CAS</strong>实现的。</p>
<p>发生死锁应该怎么办？：1，直接进入等待，直到超时。2，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务。</p>
<h2 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版 本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保 证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。</p>
<p>MVCC是快照读，是一种乐观锁的体现</p>
<p>MVCC的实现依赖于：隐藏字段、 Undo Log版本链、 Read View</p>
<p>隐藏字段，trx_id, 最近被哪个事务修改过，记录其Id。 roll_pointer 是undo log 版本链的指针。</p>
<p>核心问 题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>ReadView就是事务A在使用MVCC机制进行快照读操作时产生的读视图。</p>
<p>ReadView里面的内容：1.创建这个ReadView的事务Id, 2.生成ReadView时，当前系统中活跃的事务id的列表</p>
<p>3.活跃的事务中最小的事务Id 4. 生成ReadView时系统中应该分配给下一个事务的id. (所有事务id中最大的id+1)</p>
<p>查找规则：按照ReadView里面的事务id去Undo Log里面去查，找一样的版本。或者小于活跃的最小值，或者在活跃的最大值和最小值之间，但是不在ReadView里（即不活跃，已提交的事务）</p>
<p>操作流程：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据</li>
</ol>
<p>因为读未提交可以读到最新数据，串行化读也是。所以只考虑读已提交和可重复读的MVCC</p>
<p>READ COMMITTED ：每次读取数据前都生成一个ReadView。</p>
<p>使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之 后的查询就不会重复生成了。</p>
<p>可重复读如何解决幻读的？因为只生成了最开始的一个ReadView，生成ReadView的时机。</p>
<h1 id="5-多线程编程"><a href="#5-多线程编程" class="headerlink" title="5.多线程编程"></a>5.多线程编程</h1><h2 id="synchronized-amp-wait-amp-notify-amp-sleep-amp-lock"><a href="#synchronized-amp-wait-amp-notify-amp-sleep-amp-lock" class="headerlink" title="synchronized &amp; wait &amp; notify &amp;sleep &amp;lock"></a>synchronized &amp; wait &amp; notify &amp;sleep &amp;lock</h2><h3 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h3><p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p>不同点</p>
<ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同（重点）</p>
<ul>
<li><strong>wait 方法的调用必须先获取 wait 对象的锁</strong>，而 sleep 则无此限制</li>
<li><strong>wait 方法执行后会释放对象锁</strong>，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li><strong>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁</strong>（我放弃 cpu，你们也用不了）</li>
</ul>
<p>备注：<br>没有获得对象锁，是不能调用wait()的。 Lock.wait()是不对的。要synchronized(Lock){Lock.wait();}</p>
</li>
</ul>
<h3 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h3><p>不同点</p>
<ul>
<li>语法层面<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li><strong>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</strong></li>
</ul>
</li>
<li>功能层面<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li><strong>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</strong></li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><pre class=" language-java"><code class="language-java">ReentrantLock lock<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//任务</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="ReentrantLock的lock方法"><a href="#ReentrantLock的lock方法" class="headerlink" title="ReentrantLock的lock方法"></a>ReentrantLock的lock方法</h3><p>进入到lock方法后，发现内部调用了sync.lock()方法，他有两个实现</p>
<p>FairSync:公平锁 NonfairSync:非公平锁,先用CAS抢锁，然后再排队 源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>AQS(AbstractQueuedSynchronizer)内部维护着一个队列（或者说是双向链表）</p>
<p>AQS内部三个变量，head,tail,state. 线程用CAS的方法让state从0变为1，这样就是获得锁了。</p>
<p>没有拿到锁的线程就进入AQS的队列了。</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/%E7%AE%80%E5%8E%861/QQ%E5%9B%BE%E7%89%8720230430230101.jpg" alt="img"></p>
<p>对于NonfairSync来说</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>对于FairSync来说</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>tryAcquire方法：tryAcquire方法是AQS提供的，内部没有任何实现，需要继承AQS的类自己去实现逻辑代码。</p>
<p>查看到tryAcquire在ReentrantLock中提供了两种实现：公平锁、非公平锁。</p>
<p>addWaiter方法：在线程没有通过tryAcquire拿到锁资源时，需要将当前线程封装为Node对象，去AQS内部排队。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>acquiredQueued方法：查看当前线程是否排在队伍前面，如果是，则取获取锁；如果长时间没拿到锁，则需要将当前线程挂起。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>unlock释放锁操作不分为公平和非公平，都是执行sync的release方法</p>
<p>释放锁的核心，就是将state从大于0的数更改为0即为释放锁成功</p>
<p>并且unlock方法应该会涉及到将AQS队列中阻塞的线程进行唤醒，阻塞用的方法是park方法，唤醒必然是unpark方法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>要求</strong></p>
<ul>
<li>掌握线程安全要考虑的三个问题-可见性，有序性，原子性</li>
<li>掌握 volatile 能解决哪些问题-可以解决可见性和有序性，不能解决原子性</li>
</ul>
<p>可见性：一个线程对共享变量修改，另一个线程能看到最新的结果</p>
<p>有序性：一个线程内代码按编写顺序执行</p>
<p>原子性：一个线程内多行代码以一个整体运行，期间不能有其他线程的代码插队</p>
<p><strong>原子性</strong></p>
<ul>
<li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li>
<li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li>
</ul>
<p><strong>可见性</strong></p>
<ul>
<li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li>
<li>解决：<strong>用 volatile 修饰共享变量</strong>，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li>
</ul>
<p><strong>有序性</strong></p>
<ul>
<li><p>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</p>
</li>
<li><p>解决：<strong>用 volatile 修饰共享变量</strong>会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
</li>
<li><p>注意：</p>
<p>内存屏障</p>
<ul>
<li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li>
<li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li>
<li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li>
</ul>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>乐观锁的代表是 AtomicInteger，使用 CAS(compare and swap)来保证原子性。AtomicInteger的底层是Unsafe。</p>
<ul>
<li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li>
<li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li>
<li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>ConcurrentHashMap 1.7</strong></p>
<ul>
<li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li>
<li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li>
<li>三个初始变量（capacity, factor, clevel)小数组的长度等于capacity&#x2F;clevel,小于2则取2.</li>
<li>索引计算<ul>
<li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li>
<li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li>
</ul>
</li>
<li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li>
<li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li>
</ul>
<p><strong>ConcurrentHashMap 1.8</strong></p>
<ul>
<li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li>
<li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li>
<li>扩容条件：Node 数组满 3&#x2F;4 时就会扩容(3&#x2F;4指的是元素个数&#x2F;数组长度)</li>
<li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li>
<li>扩容时并发 get<ul>
<li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li>
<li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li>
<li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li>
</ul>
</li>
<li>扩容时并发 put<ul>
<li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li>
<li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li>
<li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li>
</ul>
</li>
<li>与 1.7 相比是懒惰初始化</li>
<li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ （即当capacity&#x3D;16,且factor&#x3D;0.75时，会初始化出一个size&#x3D;32的数组）</li>
<li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3&#x2F;4</li>
<li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li>
</ul>
<h2 id="ThreadLocal-不会"><a href="#ThreadLocal-不会" class="headerlink" title="ThreadLocal(不会)"></a>ThreadLocal(不会)</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 ThreadLocal 的作用与原理</li>
<li>掌握 ThreadLocal 的内存释放时机</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程状态：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230426153243.png" alt="img"></p>
<p>线程池的核心参数：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/%E7%AE%80%E5%8E%861/QQ%E5%9B%BE%E7%89%8720230427155254.png" alt="img"></p>
<p>keepAliveTime是没有任务以后救急线程会生存多久。</p>
<p>当核心线程和阻塞队列满了之后，才会创造救急线程。</p>
<p>比如1和2任务在被核心线程被执行，3和4任务在阻塞队列中，5任务来了。生成救急线程，执行5任务，然后再执行3任务和4任务。</p>
<p>代码实现：</p>
<p><img src="https://web-1107.oss-cn-nanjing.aliyuncs.com/%E7%AE%80%E5%8E%861/QQ%E5%9B%BE%E7%89%8720230427160251.jpg" alt="img"></p>
<h1 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6.Redis"></a>6.Redis</h1><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>详细请参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2238792">这篇文章</a></p>
<p>五种基本数据类型：字符串（strings），散列表（hashes）， 列表（lists），集合（set），有序集合（sortedset）</p>
<p>三种特殊数据类型：地理位置（Geospatial），基数统计(Hyperloglog), 位图(Bitmap)</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">爱敲代码の鱼儿</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://19shuidiph.github.io/2023/06/26/ge-ren-jian-li/">http://19shuidiph.github.io/2023/06/26/ge-ren-jian-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">爱敲代码の鱼儿</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/26/shu-ru-shu-chu-liu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="输入输出流">
                        
                        <span class="card-title">输入输出流</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            针对于笔试的一些输入输出数据做一些小结。
主要是关于String相关的，当然也有一点数组和输入数据相关的。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/26/di-yi-pian-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="第一篇笔记-主题和内容介绍">
                        
                        <span class="card-title">第一篇笔记-主题和内容介绍</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第一篇笔记-主题和内容介绍搭建个人博客这边主要是按照wushishu(不过这个网站现在已经寄了）的来进行搭建，还参考了这篇知乎文章,还要把Blog下的_config.yml中的https改为http;
风格主题的话采用的就是我的友链argv
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            爱敲代码の鱼儿
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">爱敲代码の鱼儿</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/19shuidiph" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1207649878@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1207649878" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1207649878" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
